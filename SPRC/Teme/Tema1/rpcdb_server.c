/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "rpcdb.h"

users *userss = NULL;

void free_memory_database(memory_database *list) {
	printf("Freeing memory database for logged out user...\n");
	memory_database *pointer;

	while(list != NULL) {
		pointer = list;
		list = list->next;
		free(pointer);
	}
}

user_data* check_if_token_valid(u_quad_t token) {
	users *iterator;

	if (token != REJECTED_TOKEN) {
		iterator = userss;
    	while (iterator != NULL) {
            if (iterator->user.token == token) {
                return &(iterator->user);
            }
            iterator = iterator->next;
        }
	}

    return NULL;
}

void login(package *argp, char *command, package *result) {
	users *iterator, *previous, *new_user;

    printf("Received `LOGIN` command.\n");

	char *user_name = strtok(command, " ");
	if (user_name == NULL) {
		result->message = "[ERROR-1] Could not parse user name for login command!";
		printf("%s\n", result->message);
		return;
	}
	user_name = strtok(NULL, " \n");
	if (user_name == NULL) {
		result->message = "[ERROR-2] Could not parse user name for login command!";
        printf("%s\n", result->message);
        return;
    }

    printf("Logging in user '%s'...\n", user_name);
    if (userss == NULL) {
        userss = (users*) calloc (1, sizeof(users));
        new_user = userss;

    } else {
        iterator = userss;
        while (iterator != NULL) {
            if (strcmp(iterator->user.user_name, user_name) == 0) {
                if ((iterator->user.token == REJECTED_TOKEN) || (iterator->user.token == argp->token)) {
                    iterator->user.mem_database = NULL;

                    iterator->user.token = rand();
                    iterator->user.token = (iterator->user.token << 32) | rand();

                    result->message = "[SUCCESSFUL-1] Welcome back! (Re)Login succesful!";
                    result->token = iterator->user.token;

                } else {
                    result->message = "[ERROR-3] Login error! User already authenticated!";
                    result->token = REJECTED_TOKEN;
                }

                printf("%s\n", result->message);
                return;
            }

            previous = iterator;
			iterator = previous->next;
        }

		new_user = (users*) calloc (1, sizeof(users));
		previous->next = new_user;
    }

    new_user->next = NULL;

    new_user->user.disk_database = NULL;
    new_user->user.mem_database = NULL;

    new_user->user.user_name = (char*) calloc (MAXBUF, sizeof(char));
    strcpy(new_user->user.user_name, user_name);

    new_user->user.token = rand();
    new_user->user.token = (new_user->user.token << 32) | rand();

    result->message = "[SUCCESSFUL-2] Login succesful!";
    result->token = new_user->user.token;

    printf("%s\n", result->message);

}

void logout(package *argp, package *result) {
	users *iterator;

    printf("Received `LOGOUT` command.\n");

    user_data *user = check_if_token_valid(argp->token);

    if (user == NULL) {
        result->message = "[ERROR-4] Logout failed! No users logged in or the client is not logged in!";
        printf("%s\n", result->message);
        return;

    } else {
        printf("Logging out user '%s'...\n", user->user_name);
        user->token = REJECTED_TOKEN;

		free_memory_database(user->mem_database);
        user->mem_database = NULL;

        result->message = "[SUCCESSFUL-3] Logout successful!";
        printf("%s\n", result->message);
        return;
    }
}

void add(package *argp, package *result) {
	users *iterator;

    printf("Received 'ADD' command.\n");

    user_data *user = check_if_token_valid(argp->token);

    if (user == NULL) {
        result->message = "[ERROR-5] Adding data failed! Invalid token!";
        printf("%s\n", result->message);
        return;

    } else {
        printf("Adding data for user '%s'...\n", user->user_name);

		char* add;
		int data_id = BLANK;
        int no_values = BLANK;

        char *command = (char*) calloc (MAXBUF, sizeof(char));
        strcpy(command, argp->command);

        char *string_value = strtok(command, " ");
        if (string_value == NULL) {
            result->message = "[ERROR-6] Could not parse 'ADD' command!";
            printf("%s\n", result->message);
            return;
        }

		for (int i = 0; i < 2; i++) {
			string_value = strtok(NULL, " ");
			if (string_value == NULL) {
                result->message = "[ERROR-7] Could not parse data ID and/or number of values!";
                printf("%s\n", result->message);
                return;

            } else {
                if (i == 0) {
                    data_id = atoi(string_value);
                } else {
                    no_values = atoi(string_value);
                    if (no_values < 0) {
                        result->message = "[ERROR-8] Number of values must be greater than 0!";
                        printf("%s\n", result->message);
                        return;
                    }
                }
            }
		}
		printf("Data ID: %d; Number of values: %d\nValues found: ", data_id, no_values);

		float values[no_values];
		for (int i = 0; i < no_values; i++) {
            string_value = strtok(NULL, " ");
            if (string_value == NULL) {
                result->message = "[ERROR-9] Could not parse all values!";
                printf("%s\n", result->message);
                return;

            } else {
                values[i] = atof(string_value);
                printf("%.2f; ", values[i]);
            }
        }
        printf("\n");

        user->mem_database = NULL;

        result->message = "[SUCCESSFUL-4] Adding data successful!";
        printf("%s\n", result->message);
        return;
    }
}

package* command_1_svc(package *argp, struct svc_req *rqstp) {
	static package result;

	result.command = "";
    result.message = "";
    static float values[0];
    result.data.array.array_len = 0;
    result.data.array.array_val = values;

    printf("Received command '%s'.\n", argp->command);

	char *command = argp->command;
	if (strstr(command, LOGIN_COMMAND) == command) {
		login(argp, command, &result);
    } else if (strstr(command, LOGOUT_COMMAND) == command) {
        logout(argp, &result);
    } else if (strstr(command, ADD_COMMAND) == command) {
        add(argp, &result);
    } else if (strstr(command, DEL_COMMAND) == command) {
        printf("%s\n", DEL_COMMAND);
    } else if (strstr(command, UPDATE_COMMAND) == command) {
        printf("%s\n", UPDATE_COMMAND);
    } else if (strstr(command, READ_COMMAND) == command) {
        printf("%s\n", READ_COMMAND);
    } else if (strstr(command, GET_STAT_COMMAND) == command) {
        printf("%s\n", GET_STAT_COMMAND);
    } else if (strstr(command, GET_STAT_ALL_COMMAND) == command) {
        printf("%s\n", GET_STAT_ALL_COMMAND);
    } else if (strstr(command, STORE_COMMAND) == command) {
        printf("%s\n", STORE_COMMAND);
    } else if (strstr(command, LOAD_COMMAND) == command) {
        printf("%s\n", LOAD_COMMAND);
    } else {
        result.message = "[ERROR] Could not interpret command!";
        printf("%s\n", result.message);
    }

	return &result;
}